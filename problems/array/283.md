## Problema
Categoria: Array

Problema: 283.Move Zeroes

Nível de dificuldade: Fácil

Link: https://leetcode.com/problems/move-zeroes/description

---

## Solução
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int size = nums.size();
        auto it = remove(nums.begin(), nums.end(), 0);
        nums.erase(it,nums.end());
        size -= nums.size();
        for(int i{}; i < size; ++i){
            nums.push_back(0);
        }
    }
};

```

---

## Entendendo o problema e solução

Dado um array de inteiros **nums**, devemos mover todos os zeros para o final do array, mantendo a ordem relativa dos elementos diferentes de zero. 
>[!NOTE]
>Deve-se fazer isso in-place, sem criar uma cópia do contêiner.

- Bem, primeiro criamos o inteiro **size** que recebe o tamanho inicial do array;
- A função **remove** definida pelo cabeçalho **<**algorithm**>**, inicialmente, ela não elimina o elemento desejado, ao invés disso, ela os move para o final do contêiner e retorna um iterador para o final dos números diferentes do que será removido. Por este motivo, criei um auto **it** que aponta para o primeiro elemento dos que serão removidos;
- Agora fazendo uso da função **erase**, vamos de fato remover os elementos entre **it** e **nums.end()** que é o final do contêiner;
- O intero **size** declarado anteriormente é utilizado para descobrirmos quantos zeros existem no array. Portanto, agora, pegamos **size** que atualmente guarda o tamanho do array no inicio do algoritmo e subtraimos o tamanho atual do array; 
- Por último, criamos um loop tendo como parâmetro **size**(a quantidade de zeros) e em cada iteração usamos **push_back** para adicionar um '0' no final do contêiner.

>[!NOTE]
>Talvez você se pergunte porque não finalizei após a fução 'remove'. a resposta é porque os elementos no final do intervalo, após o novo "final lógico", ficam em um estado válido, mas não especificado (eles podem ser cópias dos elementos remanescentes ou manter seus valores originais).
